'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var effector = require('effector');
var inspector = require('effector-inspector');
var debounce = require('just-debounce-it');
var isNode = require('detect-node');
var set = require('set-value');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var inspector__namespace = /*#__PURE__*/_interopNamespace(inspector);
var debounce__default = /*#__PURE__*/_interopDefaultLegacy(debounce);
var isNode__default = /*#__PURE__*/_interopDefaultLegacy(isNode);
var set__default = /*#__PURE__*/_interopDefaultLegacy(set);

var _effectorFileName$1 = "/src/lib.ts";
const LOGGER_DOMAIN_NAME = '@effector-logger';
function createName(composite) {
  return composite.path.filter(name => name !== LOGGER_DOMAIN_NAME).join('/');
}
function getPath(unit) {
  var _a, _b, _c;

  return (_c = (_b = (_a = unit.defaultConfig) === null || _a === void 0 ? void 0 : _a.loc) === null || _b === void 0 ? void 0 : _b.file) !== null && _c !== void 0 ? _c : ' ';
}

function watchDomain(unit, domain, fn) {
  if (effector.is.store(unit, {
    loc: {
      file: _effectorFileName$1,
      line: 11,
      column: 8
    },
    sid: "-6vukfe"
  })) {
    fn(unit.getState());
  }

  const watchUnit = effector.is.store(unit, {
    loc: {
      file: _effectorFileName$1,
      line: 14,
      column: 22
    },
    name: "watchUnit",
    sid: "-tu8c8a"
  }) ? unit.updates : unit;
  watchUnit.watch(fn);
}

function watchScope(unit, scope, fn) {
  if (effector.is.store(unit, {
    loc: {
      file: _effectorFileName$1,
      line: 18,
      column: 8
    },
    sid: "-6s009v"
  })) {
    fn(scope.getState(unit));
  }

  const node = effector.createNode({
    node: [effector.step.run({
      fn
    })]
  });
  const watchUnit = effector.is.store(unit, {
    loc: {
      file: _effectorFileName$1,
      line: 24,
      column: 22
    },
    name: "watchUnit",
    sid: "-f5u209"
  }) ? unit.updates : unit;
  const id = watchUnit.graphite.id;
  const links = scope.additionalLinks[id] = scope.additionalLinks[id] || [];
  links.push(node);
}

function watch(unit, source, fn) {
  if (effector.is.domain(source, {
    loc: {
      file: _effectorFileName$1,
      line: 31,
      column: 8
    },
    sid: "-5xrbn0"
  })) {
    watchDomain(unit, source, fn);
  } else {
    watchScope(unit, source, fn);
  }
}

const SEPARATOR = isNode__default['default'] ? '  ' : '';
const storeListToInit = [];
const eventListToInit = [];
const effectListToInit = [];
const styles = {
  block: 'padding-left: 4px; padding-right: 4px; font-weight: normal;',
  chunk: 'padding-left: 4px; padding-right: 4px; font-weight: normal;',
  effector: 'line-height:1.5; color: #000; font-family: "Apple Emoji Font"; font-weight: normal !important;',
  new: 'background-color: #29b6f6; color: #000',
  store: 'background-color: #7e57c2; color: #fff',
  event: 'background-color: #9ccc65; color: #000',
  effect: 'background-color: #26a69a; color: #000',
  emoji: '',
  file: 'color: #9e9e9e; padding-left: 20px;',
  reset: 'color: currentColor; background-color: transparent;'
};
const effectorLabel = [['☄️', '%s', styles.effector], ['effector', '%s', 'font-family: Menlo, monospace;']];

const reset = (index, count, style) => index === count - 1 ? styles.reset : style;

function log(blocks, chunks, group = undefined) {
  const str = [];
  const params = [];
  blocks.unshift(...effectorLabel);
  blocks.forEach(([value, view, style], index) => {
    str.push(`%c${view}%c`);
    params.push(`${styles.block} ${style}`, value, reset(index, blocks.length, `${styles.block} ${style}`));
  });
  chunks.forEach(([value, view, style]) => {
    str.push(`%c${view}`);
    params.push(`${styles.chunk} ${style}`, value);
  });
  const args = [str.join(SEPARATOR), ...params];

  if (group === 'open') {
    console.group(...args);
  } else if (group === 'collapsed') {
    console.groupCollapsed(...args);
  } else {
    console.log(...args);
  }
}

const blockNew = ['new', '%s', styles.new];

const stripDomain = name => name.split('/').pop() || name;

const createBlockStore = name => [stripDomain(name), '%s', styles.store];

const createBlockEvent = name => [stripDomain(name), '%s', styles.event];

const createBlockEffect = name => [stripDomain(name), '%s', styles.effect];

const logAdded = debounce__default['default'](() => {
  const stores = storeListToInit.splice(0);
  const events = eventListToInit.splice(0);
  const effects = effectListToInit.splice(0);

  if (stores.length + events.length + effects.length > 0) {
    log([blockNew], [['Initialized', '%s', ''], [`events(${events.length})`, '%s', ''], [`effects(${effects.length})`, '%s', ''], [`stores(${stores.length})`, '%s', '']], 'collapsed');

    if (stores.length) {
      stores.forEach(store => {
        const name = createName(store.compositeName);
        const fileName = getPath(store);
        log([blockNew, createBlockStore(name)], [['-> ', '%s', ''], [store.getState(), '%o', ''], [fileName, '%s', styles.file], [name, '%s', '']]);
      });
    }

    if (events.length > 0) {
      events.forEach(event => {
        const name = createName(event.compositeName);
        const fileName = getPath(event);
        log([blockNew, createBlockEvent(name)], [[fileName, '%s', styles.file], [name, '%s', '']]);
      });
    }

    if (effects.length > 0) {
      effects.forEach(effect => {
        const name = createName(effect.compositeName);
        const fileName = getPath(effect);
        log([blockNew, createBlockEffect(name)], [[fileName, '%s', styles.file], [name, '%s', '']]);
      });
    }

    console.groupEnd();
  }
}, 5);
function storeAdded$1(store) {
  storeListToInit.push(store);
  logAdded();
}
function eventAdded(event) {
  eventListToInit.push(event);
  logAdded();
}
function effectAdded$1(effect) {
  effectListToInit.push(effect);
  logAdded();
}
function storeUpdated$1(name, fileName, value) {
  log([createBlockStore(name)], [['-> ', '%s', ''], [value, '%o', ''], [fileName, '%s', styles.file], [name, '%s', styles.file]]);
}
function eventCalled$1(name, fileName, payload) {
  log([createBlockEvent(name)], [[payload, '%o', 'padding-left: 4px;'], [fileName, '%s', styles.file], [name, '%s', styles.file]]);
}
function effectCalled$1(name, fileName, parameters) {
  log([createBlockEffect(name)], [[parameters, '%o', 'padding-left: 4px;'], [fileName, '%s', styles.file], [name, '%s', styles.file]]);
}
function effectDone$1(name, fileName, parameters, result) {
  log([createBlockEffect(name)], [['done ✅', '%s', styles.emoji], [parameters, '(%o)', 'padding-left: 4px;'], ['-> ', '%s', ''], [result, '%o', 'padding: 0;'], [fileName, '%s', styles.file], [name, '%s', styles.file]]);
}
function effectFail$1(name, fileName, parameters, error) {
  const instanceofError = error instanceof Error;
  log([createBlockEffect(name)], [['fail ❌', '%s', styles.emoji], [parameters, '(%o)', 'padding-left: 4px;'], ['-> ', '%s', ''], instanceofError ? [String(error), '%s', ''] : [error, '%o', 'padding: 0;'], [fileName, '%s', styles.file], [name, '%s', styles.file]], instanceofError ? 'collapsed' : undefined);

  if (instanceofError) {
    log([], [[' ', '%s', ''], [error, '%o', 'padding-left: 20px;']]);
  }

  console.groupEnd();
}

/* eslint-disable @typescript-eslint/ban-ts-ignore, @typescript-eslint/no-explicit-any */

const reduxDevTools = // @ts-ignore
typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION__;

function instanceId() {
  if (typeof document === 'object') {
    return `☄️ ${document.title}`;
  }

  return '☄️ no title instance';
}

const devToolConfig = {
  instanceId: instanceId()
};
const rootState = {};

function setState(name, value) {
  set__default['default'](rootState, name.replace(/\//g, '.'), value);
}

function eventCalled(name, payload) {
  if (reduxDevTools) {
    reduxDevTools.send({
      type: `${name} (event)`,
      payload
    }, rootState, devToolConfig);
  }
}
function storeAdded(store) {
  const name = createName(store.compositeName);
  setState(name, store.defaultState);
}
function storeUpdated(name, value) {
  setState(name, value);

  if (reduxDevTools) {
    reduxDevTools.send({
      type: `${name} (store updated)`,
      value
    }, rootState, devToolConfig);
  }
}

function effectUpdateState(name, effect) {
  setState(name, {
    inFlight: effect.inFlight.getState(),
    pending: effect.pending.getState()
  });
}

function effectAdded(name, effect) {
  effectUpdateState(name, effect);
}
function effectCalled(name, effect, parameters) {
  effectUpdateState(name, effect);

  if (reduxDevTools) {
    reduxDevTools.send({
      type: `${name} (effect called)`,
      params: parameters
    }, rootState, devToolConfig);
  }
}
function effectDone(name, effect, parameters, result) {
  effectUpdateState(name, effect);

  if (reduxDevTools) {
    reduxDevTools.send({
      type: `${name}.done (effect finished)`,
      params: parameters,
      result
    }, rootState, devToolConfig);
  }
}
function effectFail(name, effect, parameters, error) {
  effectUpdateState(name, effect);

  if (reduxDevTools) {
    reduxDevTools.send({
      type: `${name}.fail (effect finished)`,
      params: parameters,
      error
    }, rootState, devToolConfig);
  }
}

var _effectorFileName = "/src/attach.ts";
const defaults = {
  reduxDevtools: 'enabled',
  console: 'enabled',
  inspector: 'enabled'
};

const defaultConfigure = () => ({
  log: 'enabled'
});

function withConfig(unit, partial) {
  const source = unit;

  if (!source['effector-logger']) {
    source['effector-logger'] = defaultConfigure();
  }

  if (partial) {
    source['effector-logger'] = Object.assign(Object.assign({}, source['effector-logger']), partial);
  }

  return source;
}

function configure(unit, config) {
  if (Array.isArray(unit)) {
    unit.forEach(unit => withConfig(unit, config));
    return;
  }

  withConfig(unit, config);
}

function shouldLog(unit) {
  return withConfig(unit)['effector-logger'].log === 'enabled';
}

function attachLogger(source, logTo = {}) {
  const options = Object.assign(Object.assign({}, defaults), logTo);
  const isConsole = options.console === 'enabled';
  const isRedux = options.reduxDevtools === 'enabled';
  const isInspector = options.inspector === 'enabled';

  function attachEvent(event) {
    const name = createName(event.compositeName);
    const fileName = getPath(event);
    if (isConsole) eventAdded(event);
    if (isInspector) inspector__namespace.addEvent(event);
    watch(event, source, payload => {
      if (shouldLog(event)) {
        if (isConsole) eventCalled$1(name, fileName, payload);
        if (isRedux) eventCalled(name, payload);
      }
    });
  }

  function attachStore(store) {
    const name = createName(store.compositeName);
    const fileName = getPath(store);
    if (isConsole) storeAdded$1(store);
    if (isRedux) storeAdded(store);
    if (isInspector) inspector__namespace.addStore(store);
    const storeMap = store.map.bind(store);

    store.map = (fn, firstState) => {
      const mappedStore = storeMap(fn, firstState);
      mappedStore.compositeName.path = store.compositeName.path.slice(0, -1);
      mappedStore.compositeName.path.push(store.compositeName.path.slice(-1) + ' -> *');
      if (isInspector) inspector__namespace.addStore(mappedStore, {
        mapped: true
      });
      return mappedStore;
    };

    watch(store, source, value => {
      if (shouldLog(store)) {
        if (isConsole) storeUpdated$1(name, fileName, value);
        if (isRedux) storeUpdated(name, value);
      }
    });
  }

  function attachEffect(effect) {
    const name = createName(effect.compositeName);
    const fileName = getPath(effect);
    if (isConsole) effectAdded$1(effect);
    if (isRedux) effectAdded(name, effect);
    if (isInspector) inspector__namespace.addEffect(effect);
    watch(effect, source, parameters => {
      if (shouldLog(effect)) {
        if (isConsole) effectCalled$1(name, fileName, parameters);
        if (isRedux) effectCalled(name, effect, parameters);
      }
    });
    watch(effect.done, source, ({
      params,
      result
    }) => {
      if (shouldLog(effect)) {
        if (isConsole) effectDone$1(name, fileName, params, result);
        if (isRedux) effectDone(name, effect, params, result);
      }
    });
    watch(effect.fail, source, ({
      params,
      error
    }) => {
      if (shouldLog(effect)) {
        if (isConsole) effectFail$1(name, fileName, params, error);
        if (isRedux) effectFail(name, effect, params, error);
      }
    });
  }

  if (effector.is.domain(source, {
    loc: {
      file: _effectorFileName,
      line: 120,
      column: 8
    },
    sid: "-w5ukap"
  })) {
    source.onCreateEvent(attachEvent);
    source.onCreateStore(attachStore);
    source.onCreateEffect(attachEffect);
  } else {
    const root = source.cloneOf;

    if (root === undefined) {
      throw new Error('Scope should be created from domain');
    }

    for (const event of root.history.events) {
      attachEvent(event);
    }

    for (const effect of root.history.effects) {
      attachEffect(effect);
    }

    for (const store of root.history.stores) {
      attachStore(store);
    }
  }
}

exports.LOGGER_DOMAIN_NAME = LOGGER_DOMAIN_NAME;
exports.attachLogger = attachLogger;
exports.configure = configure;
//# sourceMappingURL=attach.js.map
