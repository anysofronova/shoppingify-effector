((e,t)=>{'object'==typeof exports&&'undefined'!=typeof module?t(exports):'function'==typeof define&&define.amd?define(['exports'],t):t((e='undefined'!=typeof globalThis?globalThis:e||self).effector={})})(this,(e=>{function t(e,t){for(let r in e)t(e[r],r)}function r(e,t){e.forEach(t)}function n(e,t){if(!e)throw Error(t)}function a(e,t){se={parent:se,value:e,template:te(e,'template')||fe(),sidRoot:te(e,'sidRoot')||se&&se.sidRoot};try{return t()}finally{se=Z(se)}}function o({node:e=[],from:t,source:n,parent:a=t||n,to:o,target:i,child:l=o||i,scope:s={},meta:f={},family:d={type:'regular'},regional:u}={}){let c=ce(a),p=ce(d.links),m=ce(d.owners),h=[];r(e,(e=>e&&H(h,e)));let g={id:le(),seq:h,next:ce(l),meta:f,scope:s,family:{type:d.type||N,links:p,owners:m}};return r(p,(e=>H(J(e),g))),r(m,(e=>H(K(e),g))),r(c,(e=>H(e.next,g))),u&&se&&ue(X(se),[g]),g}function i(e,t,n){let a=Je,o=null,i=We;if(e.target&&(t=e.params,n=e.defer,a='page'in e?e.page:a,e.stack&&(o=e.stack),i=ee(e)||i,e=e.target),i&&We&&i!==We&&(We=null),Array.isArray(e))for(let r=0;r<e.length;r++)Ve('pure',a,G(e[r]),o,t[r],i);else Ve('pure',a,G(e),o,t,i);if(n&&!He)return;let l,s,f,d,u,c,p={isRoot:He,currentPage:Je,scope:We,isWatch:Ue,isPure:Ge};He=0;e:for(;d=Ee();){let{idx:e,stack:t,type:n}=d;f=t.node,Je=u=t.page,We=ee(t),u?c=u.reg:We&&(c=We.reg);let a=!!u,o=!!We,i={fail:0,scope:f.scope};l=s=0;for(let r=e;r<f.seq.length&&!l;r++){let d=f.seq[r];if(d.order){let{priority:a,barrierID:o}=d.order,i=o?u?`${u.fullID}_${o}`:o:0;if(r!==e||n!==a){o?Le.has(i)||(Le.add(i),Te(r,t,a,o)):Te(r,t,a);continue e}o&&Le.delete(i)}switch(d.type){case'mov':{let e,r=d.data;switch(r.from){case I:e=X(t);break;case F:case'b':e=t[r.from];break;case q:e=r.store;break;case S:if(c&&!c[r.store.id])if(a){let e=Xe(u,r.store.id);t.page=u=e,e?c=e.reg:o?(Ze(We,r.store,0,1,r.softRead),c=We.reg):c=void 0}else o&&Ze(We,r.store,0,1,r.softRead);e=ze(c&&c[r.store.id]||r.store)}switch(r.to){case I:t.value=e;break;case F:case'b':t[r.to]=e;break;case S:Ye(u,We,f,r.target).current=e}break}case'compute':let e=d.data;if(e.fn){Ue='watch'===te(f,'op'),Ge=e.pure;let r=e.safe?(0,e.fn)(X(t),i.scope,t):et(i,e.fn,t);e.filter?s=!r:t.value=r,Ue=p.isWatch,Ge=p.isPure}}l=i.fail||s}if(!l){let e=X(t);r(f.next,(r=>{Ve('child',u,r,t,e,ee(t))}));let n=ee(t);if(n){te(f,'needFxCounter')&&Ve('child',u,n.fxCount,t,e,n),te(f,'storeChange')&&Ve('child',u,n.storeChange,t,e,n),te(f,'warnSerialize')&&Ve('child',u,n.warnSerializeNode,t,e,n);let a=n.additionalLinks[f.id];a&&r(a,(r=>{Ve('child',u,r,t,e,n)}))}}}He=p.isRoot,Je=p.currentPage,We=ee(p)}function l(e,r="combine"){let n=r+'(',a='',o=0;return t(e,(e=>{o<25&&(null!=e&&(n+=a,n+=D(e)?ne(e).fullName:e.toString()),o+=1,a=', ')})),n+')'}function s(e,t){let r,n,a=e;if(t){let a=ne(t);0===e.length?(r=a.path,n=a.fullName):(r=a.path.concat([e]),n=0===a.fullName.length?e:a.fullName+'/'+e)}else r=0===e.length?[]:[e],n=e;return{shortName:a,fullName:n,path:r}}function f(e,t){let r=t?e:e[0];ge(r);let n=r.or,a=r.and;if(a){let r=t?a:a[0];if(pe(r)&&'and'in r){let r=f(a,t);e=r[0],n={...n,...r[1]}}else e=a}return[e,n]}function d(e,...t){let r=fe();if(r){let n=r.handlers[e];if(n)return n(r,...t)}}function u(e,t){let r=(e,...t)=>(U(!te(r,'derived'),'call of derived event','createEvent'),U(!Ge,'unit call from pure function','operators like sample'),Je?((e,t,r,n)=>{let a=Je,o=null;if(t)for(o=Je;o&&o.template!==t;)o=Z(o);Qe(o);let i=e.create(r,n);return Qe(a),i})(r,n,e,t):r.create(e,t)),n=fe();return Object.assign(r,{graphite:o({meta:ut(x,r,e,t),regional:1}),create:e=>(i({target:r,params:e,scope:We}),e),watch:e=>ft(r,e),map:e=>ct(r,A,e,[Ie()]),filter:e=>ct(r,"filter",e.fn?e:e.fn,[Ie(Se,1)]),filterMap:e=>ct(r,'filterMap',e,[Ie(),Ne((e=>!he(e)),1)]),prepend(e){let t=u('* \u2192 '+r.shortName,{parent:Z(r)});return d('eventPrepend',G(t)),st(t,r,[Ie()],'prepend',e),dt(r,t),t}})}function c(e,t){let a=qe(e),l=u({named:'updates',derived:1});d('storeBase',a);let s=a.id,f={subscribers:new Map,updates:l,defaultState:e,stateRef:a,getState(){let e,t=a;if(Je){let t=Je;for(;t&&!t.reg[s];)t=Z(t);t&&(e=t)}return!e&&We&&(Ze(We,a,1),e=We),e&&(t=e.reg[s]),ze(t)},setState:e=>i({target:f,params:e,defer:1,scope:We}),reset:(...e)=>(r(e,(e=>f.on(e,(()=>f.defaultState)))),f),on:(e,t)=>(be(e,'.on','first argument'),U(!te(f,'derived'),'.on in derived store','createStore'),r(Array.isArray(e)?e:[e],(e=>{f.off(e),Y(f).set(e,lt(pt(e,f,'on',we,t)))})),f),off(e){let t=Y(f).get(e);return t&&(t(),Y(f).delete(e)),f},map(e,t){let r,n;pe(e)&&(r=e,e=e.fn),U(he(t),'second argument of store.map','updateFilter');let o=f.getState();fe()?n=null:he(o)||(n=e(o,t));let i=c(n,{name:`${f.shortName} \u2192 *`,derived:1,and:r}),l=pt(f,i,A,ke,e);return Fe(Q(i),{type:A,fn:e,from:a}),Q(i).noInit=1,d('storeMap',a,l),i},watch(e,t){if(!t||!D(e)){let t=ft(f,e);return d('storeWatch',a,e)||e(f.getState()),t}return n(me(t),'second argument should be a function'),e.watch((e=>t(f.getState(),e)))}},p=ut(S,f,t),m=f.defaultConfig.updateFilter;f.graphite=o({scope:{state:a,fn:m},node:[Ne(((e,t,r)=>(r.scope&&!r.scope.reg[a.id]&&(r.b=1),e))),Ae(a),Ne(((e,t,{a:r,b:n})=>!he(e)&&(e!==r||n)),1),m&&Ie(ke,1),Ce({from:I,target:a})],child:l,meta:p,regional:1});let h=te(f,'derived'),g='ignore'===te(f,'serialize'),y=te(f,'sid');return y&&(g||re(f,'storeChange',1),a.sid=y),y||g||h||re(f,'warnSerialize',1),n(h||!he(e),"current state can't be undefined, use null instead"),ue(f,[l]),f}function p(...e){let t,r,a;[e,a]=f(e);let o,i,l,s=e[e.length-1];if(me(s)?(r=e.slice(0,-1),t=s):r=e,1===r.length){let e=r[0];_(e)||(o=e,i=1)}if(!i&&(o=r,t)){l=1;let e=t;t=t=>e(...t)}return n(pe(o),'shape should be an object'),mt(Array.isArray(o),!l,o,a,t)}function m(){let e={};return e.req=new Promise(((t,r)=>{e.rs=t,e.rj=r})),e.req.catch((()=>{})),e}function h(e,t){let r=u(me(e)?{handler:e}:e,t),a=G(r);re(a,'op',r.kind=j),r.use=e=>(n(me(e),'.use argument should be a function'),h.scope.handler=e,r),r.use.getCurrent=()=>h.scope.handler;let l=r.finally=u({named:'finally',derived:1}),s=r.done=l.filterMap({named:'done',fn({status:e,params:t,result:r}){if('done'===e)return{params:t,result:r}}}),f=r.fail=l.filterMap({named:'fail',fn({status:e,params:t,error:r}){if('fail'===e)return{params:t,error:r}}}),d=r.doneData=s.map({named:'doneData',fn:({result:e})=>e}),p=r.failData=f.map({named:'failData',fn:({error:e})=>e}),h=o({scope:{handlerId:te(a,'sid'),handler:r.defaultConfig.handler||(()=>n(0,`no handler used in ${r.getType()}`))},node:[Ne(((e,t,r)=>{let n=t,a=n.handler;if(ee(r)){let e=ee(r).handlers[n.handlerId];e&&(a=e)}return e.handler=a,e}),0,1),Ne((({params:e,req:t,handler:r,args:n=[e]},a,o)=>{let i=gt(e,t,1,l,o),s=gt(e,t,0,l,o),[f,d]=ht(r,s,n);f&&(pe(d)&&me(d.then)?d.then(i,s):i(d))}),0,1)],meta:{op:'fx',fx:'runner'}});a.scope.runner=h,H(a.seq,Ne(((e,{runner:t},r)=>{let n=Z(r)?{params:e,req:{rs(e){},rj(e){}}}:e;return i({target:t,params:n,defer:1,scope:ee(r)}),n.params}),0,1)),r.create=e=>{let t=m(),n={params:e,req:t};if(We){if(!Ue){let e=We;t.req.finally((()=>{Ke(e)})).catch((()=>{}))}i({target:r,params:n,scope:We})}else i(r,n);return t.req};let g=r.inFlight=c(0,{serialize:'ignore'}).on(r,(e=>e+1)).on(l,(e=>e-1)).map({fn:e=>e,named:'inFlight'});re(l,'needFxCounter','dec'),re(r,'needFxCounter',1);let y=r.pending=g.map({fn:e=>e>0,named:'pending'});return ue(r,[l,s,f,d,p,y,g]),r}function g(e,t){be(e,'merge','first argument');let r=u({name:l(e,'merge'),derived:1,and:t});return st(e,r,[],'merge'),r}function y(e,t){let a=0;return r(bt,(r=>{r in e&&(n(null!=e[r],vt(t,r)),a=1)})),a}function b(e,t){let n=[];(function e(a){L(n,a)||(H(n,a),te(a,'op')===S&&te(a,'sid')&&t(a,te(a,'sid')),r(a.next,e),r(J(a),e),r(K(a),e))})(e)}function v(e,t){if(Array.isArray(e)&&(e=new Map(e)),e instanceof Map){let a={};return r(e,((e,r)=>{n(D(r),'Map key should be a unit'),t&&t(r,e),n(r.sid,'unit should have a sid'),n(!(r.sid in a),'duplicate sid found'),a[r.sid]=e})),a}return e}function k(e){let t=()=>e();return t.unsubscribe=()=>e(),t}let w='undefined'!=typeof Symbol&&Symbol.observable||'@@observable',S='store',x='event',j='effect',C='domain',$='scope',M='sampler',N='crosslink',A='map',I='stack',O='barrier',q='value',z='sample',F='a',D=e=>(me(e)||pe(e))&&'kind'in e;const R=e=>t=>D(t)&&t.kind===e;let _=R(S),P=R(x),E=R(j),V=R(C),T=R($);var B={__proto__:null,unit:D,store:_,event:P,effect:E,domain:V,scope:T};let L=(e,t)=>e.includes(t),W=(e,t)=>{let r=e.indexOf(t);-1!==r&&e.splice(r,1)},H=(e,t)=>e.push(t),U=(e,t,r)=>!e&&console.error(`${t} is deprecated${r?`, use ${r} instead`:''}`),G=e=>e.graphite||e,J=e=>e.family.owners,K=e=>e.family.links,Q=e=>e.stateRef,X=e=>e.value,Y=e=>e.subscribers,Z=e=>e.parent,ee=e=>e.scope,te=(e,t)=>G(e).meta[t],re=(e,t,r)=>G(e).meta[t]=r,ne=e=>e.compositeName;const ae=()=>{let e=0;return()=>""+ ++e};let oe=ae(),ie=ae(),le=ae(),se=null,fe=()=>se&&se.template,de=e=>(e&&se&&se.sidRoot&&(e=`${se.sidRoot}|${e}`),e),ue=(e,t)=>{let n=G(e);r(t,(e=>{let t=G(e);n.family.type!==C&&(t.family.type=N),H(J(t),n),H(K(n),t)}))},ce=(e=[])=>(Array.isArray(e)?e:[e]).flat().map(G),pe=e=>'object'==typeof e&&null!==e,me=e=>'function'==typeof e,he=e=>void 0===e,ge=e=>n(pe(e)||me(e),'expect first argument be an object');const ye=(e,t,r,a)=>n(!(!pe(e)&&!me(e)||!('family'in e)&&!('graphite'in e)),`${t}: expect ${r} to be a unit (store, event or effect)${a}`);let be=(e,t,n)=>{Array.isArray(e)?r(e,((e,r)=>ye(e,t,`${r} item of ${n}`,''))):ye(e,t,n,' or array of units')},ve=(e,t,n="target")=>r(ce(t),(t=>U(!te(t,'derived'),`${e}: derived unit in "${n}"`,"createEvent/createStore"))),ke=(e,{fn:t},{a:r})=>t(e,r),we=(e,{fn:t},{a:r})=>t(r,e),Se=(e,{fn:t})=>t(e);const xe=(e,t,r,n)=>{let a={id:ie(),type:e,data:t};return r&&(a.order={priority:r},n&&(a.order.barrierID=++je)),a};let je=0,Ce=({from:e=S,store:t,target:r,to:n=(r?S:I),batch:a,priority:o})=>xe('mov',{from:e,store:t,to:n,target:r},o,a),$e=({fn:e,batch:t,priority:r,safe:n=0,filter:a=0,pure:o=0})=>xe('compute',{fn:e,safe:n,filter:a,pure:o},r,t),Me=({fn:e})=>$e({fn:e,priority:j}),Ne=(e,t,r)=>$e({fn:e,safe:1,filter:t,priority:r&&j}),Ae=(e,t,r)=>Ce({store:e,to:t?I:F,priority:r&&M,batch:1}),Ie=(e=Se,t)=>$e({fn:e,pure:1,filter:t}),Oe={mov:Ce,compute:$e,filter:({fn:e,pure:t})=>$e({fn:e,filter:1,pure:t}),run:Me},qe=e=>({id:ie(),current:e}),ze=({current:e})=>e,Fe=(e,t)=>{e.before||(e.before=[]),H(e.before,t)},De=null;const Re=(e,t)=>{if(!e)return t;if(!t)return e;let r;return(e.v.type===t.v.type&&e.v.id>t.v.id||Be(e.v.type)>Be(t.v.type))&&(r=e,e=t,t=r),r=Re(e.r,t),e.r=e.l,e.l=r,e},_e=[];let Pe=0;for(;Pe<6;)H(_e,{first:null,last:null,size:0}),Pe+=1;const Ee=()=>{for(let e=0;e<6;e++){let t=_e[e];if(t.size>0){if(3===e||4===e){t.size-=1;let e=De.v;return De=Re(De.l,De.r),e}1===t.size&&(t.last=null);let r=t.first;return t.first=r.r,t.size-=1,r.v}}},Ve=(e,t,r,n,a,o)=>Te(0,{a:null,b:null,node:r,parent:n,value:a,page:t,scope:o},e),Te=(e,t,r,n=0)=>{let a=Be(r),o=_e[a],i={v:{idx:e,stack:t,type:r,id:n},l:null,r:null};3===a||4===a?De=Re(De,i):(0===o.size?o.first=i:o.last.r=i,o.last=i),o.size+=1},Be=e=>{switch(e){case'child':return 0;case'pure':return 1;case'read':return 2;case O:return 3;case M:return 4;case j:return 5;default:return-1}},Le=new Set;let We,He=1,Ue=0,Ge=0,Je=null,Ke=e=>{We=e},Qe=e=>{Je=e};const Xe=(e,t)=>{if(e){for(;e&&!e.reg[t];)e=Z(e);if(e)return e}return null};let Ye=(e,t,r,n,a)=>{let o=Xe(e,n.id);return o?o.reg[n.id]:t?(Ze(t,n,a),t.reg[n.id]):n},Ze=(e,t,n,a,o)=>{let i=e.reg,l=t.sid;if(i[t.id])return;let s={id:t.id,current:t.current};if(l&&l in e.sidValuesMap&&!(l in e.sidIdMap))s.current=e.sidValuesMap[l];else if(t.before&&!o){let o=0,l=n||!t.noInit||a;r(t.before,(t=>{switch(t.type){case A:{let r=t.from;if(r||t.fn){r&&Ze(e,r,n,a);let o=r&&i[r.id].current;l&&(s.current=t.fn?t.fn(o):o)}break}case'field':o||(o=1,s.current=Array.isArray(s.current)?[...s.current]:{...s.current}),Ze(e,t.from,n,a),l&&(s.current[t.field]=i[i[t.from.id].id].current)}}))}l&&(e.sidIdMap[l]=t.id),i[t.id]=s};const et=(e,t,r)=>{try{return t(X(r),e.scope,r)}catch(t){console.error(t),e.fail=1}};let tt=(e,r={})=>(pe(e)&&(tt(e.or,r),t(e,((e,t)=>{he(e)||'or'===t||'and'===t||(r[t]=e)})),tt(e.and,r)),r);const rt=(e,t)=>{W(e.next,t),W(J(e),t),W(K(e),t)},nt=(e,t,r)=>{let n;e.next.length=0,e.seq.length=0,e.scope=null;let a=K(e);for(;n=a.pop();)rt(n,e),(t||r&&'sample'!==te(e,'op')||n.family.type===N)&&nt(n,t,'on'!==te(n,'op')&&r);for(a=J(e);n=a.pop();)rt(n,e),r&&n.family.type===N&&nt(n,t,'on'!==te(n,'op')&&r)},at=e=>e.clear();let ot=(e,{deep:t}={})=>{let r=0;if(e.ownerSet&&e.ownerSet.delete(e),_(e))at(Y(e));else if(V(e)){r=1;let t=e.history;at(t.events),at(t.effects),at(t.stores),at(t.domains)}nt(G(e),!!t,r)},lt=e=>{let t=()=>ot(e);return t.unsubscribe=t,t},st=(e,t,r,n,a)=>o({node:r,parent:e,child:t,scope:{fn:a},meta:{op:n},family:{owners:[e,t],links:t},regional:1}),ft=(e,t)=>(n(me(t),'.watch argument should be a function'),lt(o({scope:{fn:t},node:[Me({fn:Se})],parent:e,meta:{op:'watch'},family:{owners:e},regional:1}))),dt=(e,t,r=x)=>{Z(e)&&Z(e).hooks[r](t)},ut=(e,t,r,n)=>{let a=e===C,o=oe(),i=tt({or:n,and:'string'==typeof r?{name:r}:r}),{parent:l=null,sid:f=null,named:d=null}=i,u=d||i.name||(a?'':o),c=s(u,l),p={op:t.kind=e,name:t.shortName=u,sid:t.sid=de(f),named:d,unitId:t.id=o,serialize:i.serialize,derived:i.derived,config:i};if(t.parent=l,t.compositeName=c,t.defaultConfig=i,t.thru=e=>(U(0,'thru','js pipe'),e(t)),t.getType=()=>c.fullName,!a){t.subscribe=e=>(ge(e),t.watch(me(e)?e:t=>e.next&&e.next(t))),t[w]=()=>t;let e=fe();e&&(p.nativeTemplate=e)}return p};const ct=(e,t,r,n)=>{let a;pe(r)&&(a=r,r=r.fn);let o=u({name:`${e.shortName} \u2192 *`,derived:1,and:a});return st(e,o,n,t,r),o},pt=(e,t,r,n,a)=>{let o=Q(t),i=Ce({store:o,to:F,priority:'read'});r===A&&(i.data.softRead=1);let l=[i,Ie(n)];return d('storeOnMap',o,l,_(e)&&Q(e)),st(e,t,l,r,a)},mt=(e,r,a,o,i)=>{let s=e?e=>e.slice():e=>({...e}),f=e?[]:{},u=s(f),p=qe(u),m=qe(1);p.type=e?'list':'shape',p.noInit=1,d('combineBase',p,m);let h=c(u,{name:l(a),derived:1,and:o}),g=Q(h);g.noInit=1,re(h,'isCombine',1);let y=Ae(p);y.order={priority:'barrier'};let b=[Ne(((e,t,r)=>(r.scope&&!r.scope.reg[p.id]&&(r.c=1),e))),y,Ce({store:m,to:'b'}),Ne(((e,{key:t},n)=>{if(n.c||e!==n.a[t])return r&&n.b&&(n.a=s(n.a)),n.a[t]=e,1}),1),Ce({from:F,target:p}),Ce({from:q,store:0,target:m}),Ce({from:q,store:1,target:m,priority:O,batch:1}),Ae(p,1),i&&Ie()];return t(a,((e,t)=>{if(!_(e))return n(!D(e)&&!he(e),`combine expects a store in a field ${t}`),void(u[t]=f[t]=e);f[t]=e.defaultState,u[t]=e.getState();let r=st(e,h,b,'combine',i);r.scope.key=t;let a=Q(e);Fe(p,{type:'field',field:t,from:a}),d('combineField',a,r)})),h.defaultShape=a,Fe(g,{type:A,from:p,fn:i}),fe()||(h.defaultState=i?g.current=i(u):f),h};let ht=(e,t,r)=>{try{return[1,e(...r)]}catch(e){return t(e),[0,null]}},gt=(e,t,r,n,a)=>o=>i({target:[n,yt],params:[r?{status:'done',params:e,result:o}:{status:'fail',params:e,error:o},{value:o,fn:r?t.rs:t.rj}],defer:1,page:a.page,scope:ee(a)});const yt=o({node:[Me({fn:({fn:e,value:t})=>e(t)})],meta:{op:'fx',fx:'sidechain'}}),bt=['source','clock','target'],vt=(e,t)=>e+`: ${t} should be defined`;let kt=(e,t,r,a,o,i,l,s,f,m,h,y)=>{let b=!!o;n(!he(r)||!he(t),vt(e,'either source or clock'));let v=0;he(r)?v=1:D(r)||(r=p(r)),he(t)?t=r:(be(t,e,'clock'),Array.isArray(t)&&(t=g(t))),v&&(r=t),s||l||(l=r.shortName);let k='none';(h||a)&&(D(a)?k='unit':(n(me(a),'`filter` should be function or unit'),k='fn')),o?(be(o,e,'target'),ve(e,o)):'none'===k&&m&&_(r)&&_(t)?o=c(i?i(ze(Q(r)),ze(Q(t))):ze(Q(r)),{name:l,sid:y,or:s}):(o=u({name:l,derived:1,or:s}),d('sampleTarget',G(o)));let w=qe(),S=[];if('unit'===k){let[r,n]=St(a,o,t,w,e);S=[...wt(n),...wt(r)]}let[x,j]=St(r,o,t,w,e);return ue(r,[st(t,o,[d('sampleSourceLoader'),Ce({from:I,target:w}),...wt(j),Ae(x,1,f),...S,Ae(w),'fn'===k&&Ie(((e,t,{a:r})=>a(e,r)),1),i&&Ie(ke),d('sampleSourceUpward',b)],e,i)]),o};const wt=e=>[Ae(e),Ne(((e,t,{a:r})=>r),1)],St=(e,t,r,n,a)=>{let i=_(e),l=i?Q(e):qe(),s=qe(i);return i||o({parent:e,node:[Ce({from:I,target:l}),Ce({from:q,store:1,target:s})],family:{owners:[e,t,r],links:t},meta:{op:a},regional:1}),d('sampleSource',s,l,n),[l,s]},xt=(e,t,r,n)=>{let a=e[t];a&&i({target:a,params:Array.isArray(a)?a.map((()=>r)):r,defer:1,stack:n})};e.allSettled=(e,{scope:t,params:r})=>{if(!D(e))return Promise.reject(new Error('first argument should be unit'));if(!E(e)&&!P(e)&&!_(e))return Promise.reject(new Error('first argument accepts only effects, events and stores'));let n=m();n.parentFork=We;let{fxCount:a}=t;H(a.scope.defers,n);let o=[e],l=[];return H(l,E(e)?{params:r,req:{rs(e){n.value={status:'done',value:e}},rj(e){n.value={status:'fail',value:e}}}}:r),H(o,a),H(l,null),i({target:o,params:l,scope:t}),n.req},e.attach=e=>{let t;[e,t]=f(e,1);let{source:r,effect:n,mapParams:a}=e,o=h(e,t);re(o,'attached',1);let l,{runner:d}=G(o).scope,u=Ne(((e,t,n)=>{let l,{params:s,req:f,handler:d}=e,u=o.finally,c=gt(s,f,0,u,n),p=n.a,m=E(d),h=1;if(a?[h,l]=ht(a,c,[s,p]):l=r&&m?p:s,h){if(!m)return e.args=[p,l],1;i({target:d,params:{params:l,req:{rs:gt(s,f,1,u,n),rj:c}},page:n.page,defer:1})}}),1,1);if(r){let e;_(r)?(e=r,ue(e,[o])):(e=p(r),ue(o,[e])),l=[Ae(Q(e)),u]}else l=[u];d.seq.splice(1,0,...l),o.use(n);let c=Z(n);return c&&(Object.assign(ne(o),s(o.shortName,c)),o.defaultConfig.parent=c),dt(n,o,j),o},e.clearNode=ot,e.combine=p,e.createApi=(...e)=>{let[[r,n],a]=f(e),o={};return t(n,((e,t)=>{let n=o[t]=u(t,{parent:Z(r),config:a});r.on(n,e),dt(r,n)})),o},e.createDomain=function e(n,a){let l=o({family:{type:C},regional:1}),s={history:{},graphite:l,hooks:{}};l.meta=ut(C,s,n,a),t({Event:u,Effect:h,Store:c,Domain:e},((e,t)=>{let n=t.toLowerCase(),a=(e=>u({named:e}))(`on${t}`);s.hooks[n]=a;let o=new Set;s.history[`${n}s`]=o,a.create=e=>(i(a,e),e),H(G(a).seq,Ne(((e,t,r)=>(r.scope=null,e)))),a.watch((e=>{ue(s,[e]),o.add(e),e.ownerSet||(e.ownerSet=o),Z(e)||(e.parent=s)})),ue(s,[a]),s[`onCreate${t}`]=e=>(r(o,e),a.watch(e)),s[`create${t}`]=s[n]=(t,r)=>a(e(t,{parent:s,or:r}))}));let f=Z(s);return f&&t(s.hooks,((e,t)=>st(e,f.hooks[t]))),s},e.createEffect=h,e.createEvent=u,e.createNode=o,e.createStore=c,e.createStoreObject=(...e)=>(U(0,'createStoreObject','combine'),p(...e)),e.createWatch=({unit:e,fn:t,scope:r})=>{let n=[Oe.run({fn:e=>t(e)})];if(r){let t=o({node:n}),a=e.graphite.id,i=r.additionalLinks,l=i[a]||[];return i[a]=l,l.push(t),k((()=>{let e=l.indexOf(t);-1!==e&&l.splice(e,1),ot(t)}))}{let t=o({node:n,parent:[e],family:{owners:e}});return k((()=>{ot(t)}))}},e.fork=(e,t)=>{let a,i=e;V(e)&&(a=e,i=t);let l=(e=>{let t=o({scope:{defers:[],inFlight:0,fxID:0},node:[Ne(((e,t,r)=>{Z(r)?'dec'===te(Z(r).node,'needFxCounter')?t.inFlight-=1:(t.inFlight+=1,t.fxID+=1):t.fxID+=1})),$e({priority:M,batch:1}),Ne(((e,t)=>{let{defers:n,fxID:a}=t;t.inFlight>0||0===n.length||Promise.resolve().then((()=>{t.fxID===a&&r(n.splice(0,n.length),(e=>{Ke(e.parentFork),e.rs(e.value)}))}))}),0,1)]}),n=o({node:[Ne(((e,t,r)=>{let n=Z(r);if(n){let t=n.node;if(!te(t,'isCombine')||Z(n)&&'combine'!==te(Z(n).node,'op')){let n=ee(r),a=t.scope.state.id,o=te(t,'sid');n.sidIdMap[o]=a,n.sidValuesMap[o]=e}}}))]}),a=o({node:[Ne(((e,t,r)=>{let n=ee(r);if(n){let e=Z(r);e&&(!te(e.node,'isCombine')||Z(e)&&'combine'!==te(Z(e).node,'op'))&&(n.warnSerialize=1)}}))]}),i={cloneOf:e,reg:{},sidValuesMap:{},sidIdMap:{},getState(e){if('current'in e)return Ye(Je,i,null,e).current;let t=G(e);return Ye(Je,i,t,t.scope.state,1).current},kind:$,graphite:o({family:{type:C,links:[t,n,a]},meta:{unit:'fork'},scope:{forkInFlightCounter:t}}),additionalLinks:{},handlers:{},fxCount:t,storeChange:n,warnSerializeNode:a};return i})(a);if(i){if(i.values){let e=v(i.values,(e=>n(_(e),'Values map can contain only stores as keys')));Object.assign(l.sidValuesMap,e)}i.handlers&&(l.handlers=v(i.handlers,(e=>n(E(e),"Handlers map can contain only effects as keys"))))}return l},e.forward=e=>{let t='forward',[{from:r,to:n},a]=f(e,1);return be(r,t,'"from"'),be(n,t,'"to"'),ve(t,n,'to'),lt(o({parent:r,child:n,meta:{op:t,config:a},family:{},regional:1}))},e.fromObservable=e=>{ge(e);let t=w in e?e[w]():e;n(t.subscribe,'expect observable to have .subscribe');let r=u(),a=lt(r);return t.subscribe({next:r,error:a,complete:a}),r},e.guard=(...e)=>{let[[t,r],n]=f(e);return r||(r=t,t=r.source),y(r,'guard'),kt('guard',r.clock,t,r.filter,r.target,null,r.name,n,!r.greedy,0,1)},e.hydrate=(e,{values:t})=>{n(pe(t),'values property should be an object');let r,a,o,l=v(t),s=Object.getOwnPropertyNames(l),f=[],d=[];T(e)?(r=e,o=1,n(r.cloneOf,'scope should be created from domain'),a=G(r.cloneOf)):V(e)?a=G(e):n(0,'first argument of hydrate should be domain or scope'),b(a,((e,t)=>{L(s,t)&&(H(f,e),H(d,l[t]))})),i({target:f,params:d,scope:r}),o&&Object.assign(r.sidValuesMap,l)},e.is=B,e.launch=i,e.merge=g,e.restore=(e,r,n)=>{if(_(e))return U(0,'restore($store)'),e;if(P(e)||E(e)){let t=Z(e),a=c(r,{parent:t,name:e.shortName,and:n});return st(E(e)?e.doneData:e,a),t&&t.hooks.store(a),a}let a=Array.isArray(e)?[]:{};return t(e,((e,t)=>a[t]=_(e)?e:c(e,{name:t}))),a},e.sample=(...e)=>{let t,r,n,a,[[o,i,l],s]=f(e),d=1;return he(i)&&pe(o)&&y(o,z)&&(i=o.clock,l=o.fn,d=!o.greedy,a=o.filter,t=o.target,r=o.name,n=o.sid,o=o.source),kt(z,i,o,a,t,l,r,s,d,1,0,n)},e.scopeBind=(e,{scope:t}={})=>{n(t||We,'scopeBind cannot be called outside of forked .watch');let r=t||We;return E(e)?t=>{let n=m();return i({target:e,params:{params:t,req:n},scope:r}),n.req}:t=>(i({target:e,params:t,scope:r}),t)},e.serialize=(e,r={})=>{e.warnSerialize&&console.error('There is a store without sid in this scope, its value is omitted');let a=r.ignore?r.ignore.map((({sid:e})=>e)):[],o={};return t(e.sidValuesMap,((t,r)=>{if(L(a,r))return;let n=e.sidIdMap[r];o[r]=n&&n in e.reg?e.reg[n].current:t})),'onlyChanges'in r&&!r.onlyChanges&&(n(e.cloneOf,'scope should be created from domain'),b(G(e.cloneOf),((t,r)=>{r in o||L(a,r)||te(t,'isCombine')||'ignore'===te(t,'serialize')||(o[r]=e.getState(t))}))),o},e.setStoreName=(e,t)=>{e.shortName=t,Object.assign(ne(e),s(t,Z(e)))},e.split=(...e)=>{let r,a,i='split',[[l,s],c]=f(e),p=!s;p&&(r=l.cases,s=l.match,a=l.clock,l=l.source);let m=_(s),h=!D(s)&&me(s),g=!m&&!h&&pe(s);r||(r={}),p?t(r,((e,t)=>ve(i,e,`cases.${t}`))):(n(g,'match should be an object'),t(s,((e,t)=>r[t]=u({derived:1,and:c}))),r.__=u({derived:1,and:c}));let y,b=new Set([].concat(l,a||[],Object.values(r))),v=Object.keys(m||h?r:s);if(m||h)m&&b.add(s),y=[m&&Ae(Q(s),0,1),$e({safe:m,filter:1,pure:!m,fn(e,t,r){let n=String(m?r.a:s(e));xt(t,L(v,n)?n:'__',e,r)}})];else if(g){let e=qe({});e.type='shape';let r,n=[];t(s,((t,a)=>{if(D(t)){r=1,H(n,a),b.add(t);let o=st(t,[],[Ae(e),Ne(((e,t,{a:r})=>r[a]=e))]);if(_(t)){e.current[a]=t.getState();let r=Q(t);Fe(e,{from:r,field:a,type:'field'}),d('splitMatchStore',r,o)}}})),r&&d('splitBase',e),y=[r&&Ae(e,0,1),Ie(((e,t,r)=>{for(let a=0;a<v.length;a++){let o=v[a];if(L(n,o)?r.a[o]:s[o](e))return void xt(t,o,e,r)}xt(t,'__',e,r)}),1)]}else n(0,'expect match to be unit, function or object');let k=o({meta:{op:i},parent:a?[]:l,scope:r,node:y,family:{owners:Array.from(b)},regional:1});if(a&&kt(i,a,l,null,k,null,i,c,0,0,0),!p)return r},e.step=Oe,e.version="22.3.0",e.withFactory=({sid:e,name:t,loc:r,method:n,fn:i})=>a(o({meta:{sidRoot:de(e),name:t,loc:r,method:n}}),i),e.withRegion=a,Object.defineProperty(e,'__esModule',{value:1})}));
//# sourceMappingURL=effector.umd.js.map
